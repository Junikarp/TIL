# Greedy Algorithm (탐욕 알고리즘)

## 탐욕 알고리즘
> * 탐욕 알고리즘은 각 단계의 부분 문제를 풀 때 근시안적으로 최적해를 구하는 방식이다.
> * 탐욕 알고리즘은 동적 계획법보다 효율적이기는 하지만 반드시 최적해를 구해준다는 보장을 하지 않는다.

### 탐욕 알고리즘 사용조건
> 탐욕 알고리즘을 사용하기 위해서는 아래의 두 조건을 만족해야하며, 이러한 구조를 `매트로이드`라고 부른다.

1. 탐욕적 선택 속성 (Greedy Choice Property)
   * 앞의 선택이 이후의 선택에 영향을 주지 않는다.
2. 최적 부분 구조 (Optimal Substructure)
   * 문제에 대한 최종 해결 방법은 부분 문제에 대한 최적 문제 해결 방법으로 구성된다.

매트로이드 구조를 만족하지 못하더라도 탐욕 알고리즘은 어느정도 최적에 근사한 값을 빠르게 도출 가능한 근사 알고리즘으로 사용 가능하다.

### 탐욕 알고리즘 동작방식
1. 해 선택
   * 현재 상태에서 부분 문제의 최적해를 구한 후 이를 부분해 집합에 추가한다.
2. 실행 가능성 검사
   * 새로운 부분해 집합이 실행 가능한 것인지 확인한다.
   * 다시 말해서, 문제의 제약 조건을 위반하지 않는지를 검사하는 것이다.
3. 해 검사
   * 새로운 부분해 집합이 문제의 해가 되는지 확인한다.
   * 아직 전체 문제의 해가 완성되지 않았다면 `단계 1`의 해 선택부터 다시 시작한다.

### 거스름돈 문제
> 거스름돈 문제는 대표적인 탐욕 알고리즘으로 해결 가능한 문제 중 하나로 거슬러줄 지폐와 동전들이 배수관계라면 탐욕 알고리즘을 통해 해결 가능하다.

#### 동작과정
1. 해 선택
   * 현재 고를 수 있는 동전 중 가장 큰 단위의 동전을 하나 골라 거스름돈에 추가한다.
2. 실행 가능성 검사
   * 거스름돈이 손님들에게 내드려야 할 액수를 초과하는지 확인한다.
   * 초과한다면 마지막에 추가한 동전을 빼고 `단계 1`로 돌아가서 현재보다 한 단계 작은 동전을 추가한다.
3. 해 검사
   * 거스름돈 액수가 모자란다면 다시 `단계 1`로 돌아가서 추가할 동전을 고른다.

#### 구현
```java
public class Main {
   public static void main(String[] args) {
      int N = 924;  //줘야할 잔돈
      int count = 0;  //잔돈으로 줘야할 동전의 갯수
      int[] money = {500, 100, 50, 10, 5, 1};  //잔돈으로 줄 수 있는 금액들
      int i = 0;
      while (n != 0) {
         if (n - money[i] >= 0) {
            n -= money[i];
            count++;
         } else {
            i++;
         }
      }
      System.out.print(count);
   }
}
```
* 결과값
```java
11
```

---
### 참조
* [이것이 자료구조 + 알고리즘이다 with C언어(박상현)](http://www.yes24.com/Product/Goods/111362116)
* [[알고리즘] 탐욕 알고리즘(Greedy Algorithm)](https://hanamon.kr/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%ED%83%90%EC%9A%95%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-greedy-algorithm/)