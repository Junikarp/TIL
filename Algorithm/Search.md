# Search (탐색 알고리즘)

## 순차 탐색
> 순차 탐색은 처음부터 끝까지 모든 요소를 비교하여 원하는 데이터를 찾는 탐색 알고리즘으로 한쪽 방향으로만 탐색 가능한 알고리즘이므로 선형 탐색으로도 불린다.
> <br> 구현이 간단하여 버그를 만들 가능성이 적으나, 모든 요소를 탐색하므로 성능이 좋지 않아 데이터의 크기가 적을 때 유리하다.

### 자기 구성법
> 자주 사용되는 항목을 데이터 앞 쪽에 배치하여 순차 탐색의 검색 효율을 올리는 방법

1. 전진 이동법
   * 탐색된 항목을 데이터의 가장 앞으로 옮기는 방법
   * 한 번 탐색된 항목이 다음에 또 검색될 확률이 높을 때 사용한다.
2. 전위법
   * 탐색된 항목을 바로 이전 항목과 교환하는 방법
   * 자주 탐색된 항목을 조금씩 앞으로 옮기므로 자주 탐색되는 항목들이 앞으로 모이게 된다.
   * 처음 위치에 따라 앞쪽의 데이터와 뒤쪽의 데이터의 위치가 크게 바뀌지 않을 가능성이 높다는 단점이 있다.
3. 계수법
   * 데이터 내 각 요소가 탐색된 횟수를 별도의 공간에 저장하고, 횟수가 높은 순으로 데이터를 재구성하는 방법
   * 계수 결과를 저장하는 별도의 공간을 유지해야하고, 재구성에 비용이 소모된다는 단점이 존재한다.

## 이진 탐색
> 이진탐색은 정렬된 데이터에서 탐색 범위를 1/2로 줄여가면서 탐색하는 고속 탐색 알고리즘이다.

### 이진 탐색 트리
> * 배열에만 사용 가능한 알고리즘인 이진 탐색을 위한 이진 트리이다.
> * 이진 탐색 트리의 각 노드는 왼쪽 자식노드는 부모보다 작고, 오른쪽 자식 노드는 부모보다 크다는 규칙을 따른다.

![Search_1.png](image%2FSearch%2FSearch_1.png)

이진 탐색트리는 데이터를 삽입하고, 삭제하는 과정에서 기형적으로 성장할 가능성이 높고, 그렇게 될 때 검색효율이 극단적으로 떨어진다는 문제점이 존재한다.

## 레드 블랙 트리
> 레드 블랙 트리는 이진 탐색 트리의 불균형한 성장으로 인한 성능 저하를 해결하기 위해서 고안된 이진 트리이다.

![Search_2.png](image%2FSearch%2FSearch_2.png)

### 레드 블랙 트리 구현 규칙
1. 모든 노드는 빨간색, 또는 검은색이다.
2. 뿌리 노드는 검은색이다.
3. 잎 노드는 검은색이다.
4. 빨간색 노드의 자식은 모두 검은색이다.
   * 검은색 노드는 빨간색과 검은색을 모두 자식으로 가질 수 있다.
5. 뿌리 노드와 모든 잎 노드 사이에 있는 검은색 노드의 수는 모두 동일하다.

### 레드 블랙 트리 기본연산

### 0. 회전
1. 우회전
   * 부모노드의 왼쪽 자식 노드 → 부모 노드
   * 왼쪽 자식 노드의 오른쪽 자식 노드 → 부모 노드의 왼쪽 자식노드
2. 좌회전
   * 부모 노드의 오른쪽 자식 노드 → 부모 노드
   * 오른쪽 자식 노드의 왼쪽 자식 노드 → 부모 노드의 오른쪽 자식 노드
   
![Search_3.png](image%2FSearch%2FSearch_3.png)

### 1. 삽입
> 삽입 노드는 항상 빨간색이며, 부모 노드의 형제 노드를 삼촌 노드, 부모 노드의 부모 노드를 할아버지 노드라고 한다.

#### Case 1) 삼촌 노드도 빨간색인 경우
1. 부모 노드, 삼촌 노드 → 검은색
2. 할아버지 노드 → 빨간색
3. 할아버지 노드를 삽입 노드라고 생각하며 루트까지 위 과정을 반복

![Search_4.png](image%2FSearch%2FSearch_4.png)

#### Case 2) 삼촌 노드가 검은색, 삽입한 노드가 부모 노드의 오른쪽 자식 노드인 경우
1. 부모를 기준으로 좌회전
2. 부모였던 노드를 삽입한 노드로 생각하고 Case 3 에 따른다.

![Search_5.png](image%2FSearch%2FSearch_5.png)

#### Case 3) 삼촌 노드가 검은색, 삽입한 노드가 부모 노드의 왼쪽 자식 노드인 경우
1. 부모 노드 → 검은색
2. 할아버지 노드 → 빨간색
3. 할아버지 노드를 우회전한다.

![Search_6.png](image%2FSearch%2FSearch_6.png)

### 2. 삭제
> 삭제 연산에서는 빨간색 노드 삭제의 경우 레드 블랙 트리 규칙을 무너뜨리지 않지만, 검은색 노드를 삭제할 경우 뒤처리가 필요하다.

#### 디폴트 케이스
* 삭제가 일어나면 무조건 실행되는 케이스로 삭제된 노드가 검은색인 경우 그 자리를 대체하는 노드를 검은색으로 칠한다.
* 이 때 그 자리를 대체하는 노드가 검은색이라면 다시 검은색을 칠하므로 이 경우를 이중 흑색 노드라고 부른다.

#### Case 1) 형제 노드가 빨간색인 경우
1. 형제 노드 → 검은색
2. 부모 노드 → 빨간색
3. 부모 노드를 기준으로 자식 노드를 좌회전한다.
4. 아래의 형제 노드가 검은색인 경우에서 해당하는 Case 에 따른다.

#### Case 2) 형제 노드가 검은색이고, 형제 노드의 양쪽 자식 노드가 모두 검은색인 경우
1. 형제 노드 → 빨간색
2. 이중 흑색 노드가 갖고 있던 2개의 검은색 중 하나를 부모 노드에게 넘김
3. 부모 노드는 형제의 상황을 보고 Case 에 따라 처리

#### Case 3) 형제 노드가 검은색이고 형제의 왼쪽 자식은 빨간색, 오른쪽 자식은 검은색인 경우
1. 형제 노드 → 빨간색
2. 왼쪽 자식 노드 → 검은색
3. 형제 노드를 기준으로 우회전
4. 이후 상황에 맞는 Case 적용

#### Case 4) 형제 노드가 검은색이고, 형제의 오른쪽 자식은 빨간색인 경우
1. 이중 흑색 노드의 부모 노드가 가진 색을 형제 노드에 칠한다.
2. 부모 노드와 형제 노드의 오른쪽 자식 노드를 검은색으로 칠한다.
3. 부모 노드를 기준으로 좌회전

### TreeSet, TreeMap
> 자바 라이브러리에서는 레드 블랙 트리의 자료구조를 쉽게 사용할 수 있도록 TreeSet 과 TreeMap 을 지원한다.


---
### 참조
* [이것이 자료구조 + 알고리즘이다 with C언어(박상현)](http://www.yes24.com/Product/Goods/111362116)
* [레드블랙트리(red-black tree) - 특징, 삽입](https://armful-log.tistory.com/24)
