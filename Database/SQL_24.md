# SQL_24

## 인덱스
> 인덱스는 테이블 내의 컬럼을 색인화 하여 검색 시 인덱스를 통해 빠르게 검색할 수 있도록 한다.
> <br>무작위로 배열된 데이터를 정렬한 뒤, 필요로 하는 데이터만 가져오기 때문에 빠른 결과를 얻는 것이 가능해진다.

![SQL_24_1.png](image%2FSQL_24%2FSQL_24_1.png)

## 인덱스 종류

### 1. 클러스터 인덱스
> * primary key 설정 시 자동으로 생성되며, 해당 primary key 칼럼 데이터가 변해도 항상 정렬을 유지한다.
> * 테이블당 1개만 허용되며, 해당 컬럼을 기준으로 물리적으로 정렬된다.
> * 조회성 쿼리 성능은 빠르나, 데이터 변경이 일어날 때 primary key 작업을 추가로 해야하므로 성능이 떨어진다.

![SQL_24_2.jpg](image%2FSQL_24%2FSQL_24_2.jpg)

### 2. 단일 인덱스
> 인덱스 생성시 하나의 칼럼만 지정하는 경우로 데이터가 많지 않은 경우 사용한다.

![SQL_24_3.png](image%2FSQL_24%2FSQL_24_3.png)

### 3. 복합 인덱스
> 인덱스를 생성할 때 칼럼을 두 개 이상 지정하는 경우로, 주로 사용하는 조회 쿼리에 조건이 많이 걸릴 시에 고려 가능하다.
 
![SQL_24_4.png](image%2FSQL_24%2FSQL_24_4.png)

### 4. 커버드 인덱스
> SQL 내에서 출력하는 칼럼 및 조건에 삽입된 칼럼이 모두 인덱스에 정보가 있어 실제 테이블을 조회하지 않고 데이터를 가지고 올 수 있는 경우에 사용된다.

![SQL_24_5.png](image%2FSQL_24%2FSQL_24_5.png)

## 인덱스 생성시 고려사항
> 인덱스를 무작정 사용하는 것은 역효과를 불러일으킬 수 있기 때문에 꼭 필요한 경우에 생성해야 한다.

### 인덱스 생성 기준

1. 테이블 내에 데이터가 많을 때 만드는 것을 권장
   * 테이블 내 데이터가 많지 않을때는 Full scan 이 Index scan 보다 빠를 수 있다.
   * 테이블 내의 데이터가 많을수록 인덱스는 더 극명한 효과를 가져오는 것이 가능하다.
2. primary key 칼럼에는 생성할 필요없음
   * primary key 가 부여된 칼럼에서는 클러스터 인덱스가 생성되므로 생성할 필요가 없다.
   * unique 제약 조건이 걸려있는 칼럼도 같은 이유로 생성할 필요가 없다.
3. cardinality 확인 후 생성
   * cardinality 는 칼럼 내 값의 분산도를 의미한다.
   * 중복값이 적을 수록 cardinality 가 높다고 할 수 있으며, 분산도가 높은 칼럼에 인덱스를 생성하는 것이 유리하다.

### 인덱스의 역효과

1. 오버헤드
   * 테이블에 데이터가 insert, update, delete 될 때 인덱스도 갱신되므로 오버헤드가 일어날 수 있다.
2. 오사용
   * 한 개의 테이블에 다수의 인덱스를 생성하면 옵티마이저가 실행계획을 만들 때 의도하지 않은 인덱스를 사용할 수 있다.
   * 사용자가 인덱스를 필요한 곳에만 적재적소에 생성하는 것이 중요하다.

## B-tree 인덱스
> B-tree 인덱스는 칼럼의 데이터를 변형시키지 않고 인덱스 내부에서 정렬된 상태를 유지한다.

### B-tree 인덱스의 구조
B-tree 인덱스는 3개의 노드로 구분 가능하다.

|           노드명            |         설명          |
|:------------------------:|:-------------------:|
|  루트 노드<br/>(Root Node)   |     최상위 노드를 칭함      |
| 브랜치 노드<br/>(Branch Node) |     최하위 노드를 칭함      |
|  리프 노드<br/>(Leaf Node)   | 루트노드와 리프노드를 연결하는 노드 |

![SQL_24_6.png](image%2FSQL_24%2FSQL_24_6.png)

* B-tree 인덱스에 값이 새로 들어오면 저장되는 키값을 이요해서 인덱스 내의 적당한 위치를 찾고, 저장위치가 결정되면 레코드의 키값과 주소정보를 B-tree 인덱스의 리프노드에 저장한다.
* 일반적으로 테이블에 데이터를 저장하는 것보다 인덱스에 추가할 때 1~1.5배의 비용이 더 발생한다.
* B-tree 인덱스 내의 키가 변경될 때는 delete and insert 가 수행되며, 단순하게 리프노드의 키값과 주소값만 변경할 수 없다.

## 인덱스를 사용할 수 없는 경우
1. Equal 로 조건절이 작성되지 않는 경우
2. like 를 사용하는 경우
3. function 을 사용하는 경우
4. 데이터 타입이 서로 다른 경우

---
### 참조
* [인덱스 종류 및 고려사항 (단일, 복합, 클러스터, 논클러스터, 커버드)](https://mozi.tistory.com/199)
* [index 의 중요성과 이해 SQL 독학 강의#24편](https://stricky.tistory.com/310)
* [B-tree, B+tree란? (인덱스와 연관지어서)](https://zorba91.tistory.com/293)